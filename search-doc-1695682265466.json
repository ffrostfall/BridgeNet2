[{"title":"Best Practices","type":0,"sectionRef":"#","url":"/BridgeNet2/docs/Tutorials/Best Practices","content":"Best Practices { &quot;label&quot;: &quot;Tutorials&quot;, &quot;position&quot;: 7 }","keywords":""},{"title":"BridgeNet2","type":0,"sectionRef":"#","url":"/BridgeNet2/api/BridgeNet2","content":"On this page BridgeNet2 The parent of all classes.","keywords":""},{"title":"Identifiers","type":0,"sectionRef":"#","url":"/BridgeNet2/docs/Technical Details/Identifiers","content":"Identifiers Identifiers are actually extremely simple: it's a shared key-value list. The key is the compressed identifier, the value is the string value. The list is stored as attributes under the BridgeNet2 RemoteEvent. Identifiers are actually just numbers compressed using string.pack- every time you create an identifier, it increments that number by one and creates the attribute. /src/Server/ServerIdentifiers.luau -- optimization for under 255 identifiers local packed = if identifierCount &lt;= 255 then string.pack(&quot;B&quot;, identifierCount) else string.pack(&quot;H&quot;, identifierCount) identifierCount += 1 identifierStorage:SetAttribute(identifierName, packed) fullIdentifierMap[identifierName] = packed compressedIdentifierMap[packed] = identifierName On the client, the client listens for new attributes added and attribute changes. It then stores these identifiers locally- the Serialize and Deserialize functions just directly interface with that table. This is why the ReferenceIdentifier function yields- it basically just waits a bit to see if the attribute loads in. If it already exists, it just accesses that in the local table. /src/Client/ClientIdentifiers.luau for id, value in identifierStorage:GetAttributes() do fullIdentifierMap[id] = value compressedIdentifierMap[value] = id end ","keywords":""},{"title":"Identifiers","type":0,"sectionRef":"#","url":"/BridgeNet2/docs/Tutorials/Using Identifiers","content":"","keywords":""},{"title":"What's the problem?​","type":1,"pageTitle":"Identifiers","url":"/BridgeNet2/docs/Tutorials/Using Identifiers#whats-the-problem","content":"We can understand firstThingToSend and anotherThingToSend as humans, but they take more bandwidth than our actual data, three times over! Bandwidth is valuable, and we don't really want to shorten the names we see just because it takes a lot of bandwidth to send. That just makes our code harder to read. "},{"title":"What's the solution?​","type":1,"pageTitle":"Identifiers","url":"/BridgeNet2/docs/Tutorials/Using Identifiers#whats-the-solution","content":"This is where identifiers come in: local sendSomeData = BridgeNet2.ReferenceBridge(&quot;sendSomeData&quot;) local firstThingToSend = BridgeNet2.ReferenceIdentifier(&quot;firstThingToSend&quot;) local anotherThing = BridgeNet2.ReferenceIdentifier(&quot;anotherThing&quot;) sendSomeData:Fire({ [firstThingToSend] = 5, [anotherThing] = false, })  At the cost of 2 lines of code, we completely solved the problem! Our code is now both readable and efficient. "},{"title":"Intro","type":0,"sectionRef":"#","url":"/BridgeNet2/docs/intro","content":"","keywords":""},{"title":"API Design​","type":1,"pageTitle":"Intro","url":"/BridgeNet2/docs/intro#api-design","content":"When using BridgeNet2, you can't fire a bridge with multiple arguments. This means you need to pass a table into Bridge:Fire if you want to send multiple arguments, instead of separate arguments. This design choice was chosen because it removes a layer of complexity, alongside being better for performance, stability, and typechecking. Doing this also means BridgeNet2 never needs to manipulate the data that's pushed, the library can just directly send that data through the RemoteEvent. "},{"title":"Singular parameter for :Fire()​","type":1,"pageTitle":"Intro","url":"/BridgeNet2/docs/intro#singular-parameter-for-fire","content":"This library favors performance, and therefore we made choices that resulted in an opinionated library. This is shown with a few decisions: cutting out varargs, opting for thread reusage which clutters the stack trace, and the PlayerContainers: BridgeNet2.Players(), BridgeNet2.ExceptPlayers(), etc. "},{"title":"Installation","type":0,"sectionRef":"#","url":"/BridgeNet2/docs/Installation","content":"","keywords":""},{"title":"Through Wally [Recommended]​","type":1,"pageTitle":"Installation","url":"/BridgeNet2/docs/Installation#through-wally-recommended","content":"If you're using Wally, you can simply drop this snippet in, except replace latest with the latest BridgeNet2 version. wally.toml [dependencies] BridgeNet2 = &quot;ffrostflame/bridgenet2@latest&quot;  "},{"title":"Standalone​","type":1,"pageTitle":"Installation","url":"/BridgeNet2/docs/Installation#standalone","content":"Download standalone.rbxm from the latest release, and then insert it into your Roblox game. "},{"title":"Logging network traffic","type":0,"sectionRef":"#","url":"/BridgeNet2/docs/Tutorials/Logging","content":"","keywords":""},{"title":"Log dumps​","type":1,"pageTitle":"Logging network traffic","url":"/BridgeNet2/docs/Tutorials/Logging#log-dumps","content":"As of right now, log dumps are not a supported feature unfortunately. However, this will be coming in the future. "},{"title":"clientBridgePrototype","type":0,"sectionRef":"#","url":"/BridgeNet2/api/clientBridgePrototype","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#functions","content":" "},{"title":"InboundMiddleware​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#InboundMiddleware","content":"&lt;/&gt; clientBridgePrototype:InboundMiddleware(middlewareTable: {(object: any) → any}) → () Sets some middleware to run when a bridge is fired from the server.  "},{"title":"OutboundMiddleware​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#OutboundMiddleware","content":"&lt;/&gt; clientBridgePrototype:OutboundMiddleware(middlewareTable: {(object: any) → any}) → () Sets some middleware to run when a bridge is fired from the local client.  "},{"title":"Fire​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#Fire","content":"&lt;/&gt; clientBridgePrototype:Fire(content: any) → () Fires the bridge locally, which can then be recieved from the server along with packet data sent along.  "},{"title":"Connect​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#Connect","content":"&lt;/&gt; clientBridgePrototype:Connect( callback: (content: Types.Content) → (), name: string? ) → RBXScriptConnection  Connects the bridge to any events recieved from the server, this is when inbound middleware is ran. This shares identical behavior with RemoteEvent.OnServerEvent:Connect.  "},{"title":"Wait​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; clientBridgePrototype:Wait() → any Connects the bridge to any events recieved from the server, this is when inbound middleware is ran. This shares identical behavior with RemoteEvent.OnServerEvent:Wait.  "},{"title":"InvokeServerAsync​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#InvokeServerAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; clientBridgePrototype:InvokeServerAsync(content: any) → any Invokes the server, then returns a value afterwards. This function yields the thread until content is recieved.  "},{"title":"Once​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#Once","content":"&lt;/&gt; clientBridgePrototype:Once(func: (content: Types.Content) → ()) → RBXScriptConnection  Connects the bridge to any events recieved from the server, this is when inbound middleware is ran. This shares identical behavior with clientBridgePrototype:Connect with the difference being that the event instantly disconnects on recieved.  "},{"title":"Destroy​","type":1,"pageTitle":"clientBridgePrototype","url":"/BridgeNet2/api/clientBridgePrototype#Destroy","content":"&lt;/&gt; clientBridgePrototype:Destroy() → () Destroys the bridge it was called on. "},{"title":"serverBridgePrototype","type":0,"sectionRef":"#","url":"/BridgeNet2/api/serverBridgePrototype","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#properties","content":" "},{"title":"OnServerInvoke​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#OnServerInvoke","content":"&lt;/&gt; serverBridgePrototype.OnServerInvoke: ( player: Player , content: Types.Content? ) → ...any Sets a function that runs when the server is invoked by the client, should return some values. "},{"title":"Functions​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#functions","content":" "},{"title":"InboundMiddleware​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#InboundMiddleware","content":"&lt;/&gt; serverBridgePrototype:InboundMiddleware(middlewareTable: {( player: Player , content: Types.Content ) → any}) → () Sets some middleware to run when a bridge is fired from the client.  "},{"title":"OutboundMiddleware​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#OutboundMiddleware","content":"&lt;/&gt; serverBridgePrototype:OutboundMiddleware(middlewareTable: {( target: Types.PlayerContainer, content: Types.Content ) → any}) → () Sets some middleware to run when a bridge is fired from the backend server.  "},{"title":"Connect​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#Connect","content":"&lt;/&gt; serverBridgePrototype:Connect( callback: ( player: Player , content: Types.Content ) → nil, name: string? ) → RBXScriptConnection  Connects the bridge to any events recieved from the client, this is when inbound middleware is ran. This shares identical behavior with RemoteEvent.OnClientEvent.  "},{"title":"RateLimit​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#RateLimit","content":"&lt;/&gt; serverBridgePrototype:RateLimit( invokesPerSecond: number,-- The maximum invokes per second allowed from the client overflowFunction: (player: Player ) → nil-- The function to run if the client runs over the maximum amount of request ) → () Sets the rate limit, which makes a bridge only allow invokesPerSecond invoke per second.  "},{"title":"DisableRateLimit​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#DisableRateLimit","content":"&lt;/&gt; serverBridgePrototype:DisableRateLimit() → () Disables the set rate limit for the bridge.  "},{"title":"Wait​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; serverBridgePrototype:Wait() → Player, any Connects the bridge to any events recieved from the client, this is when inbound middleware is ran. This shares identical behavior with RemoteEvent.OnClientEvent.  "},{"title":"Once​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#Once","content":"&lt;/&gt; serverBridgePrototype:Once(callback: ( player: Player , content: Types.Content ) → ()) → RBXScriptConnection  Connects the bridge to any events recieved from the client, this is when inbound middleware is ran. This shares identical behavior with clientBridgePrototype:Connect with the difference being that the event instantly disconnects on recieved.  "},{"title":"Fire​","type":1,"pageTitle":"serverBridgePrototype","url":"/BridgeNet2/api/serverBridgePrototype#Fire","content":"&lt;/&gt; serverBridgePrototype:Fire( target: Player | Types.PlayerContainer,-- The player which the event should be fired to content: any-- The packet data which should be sent along ) → () Fires the bridge from the backend server, which can then be recieved from the client along with packet data sent along. "},{"title":"Getting started with BridgeNet2","type":0,"sectionRef":"#","url":"/BridgeNet2/docs/Tutorials/Getting Started","content":"","keywords":""},{"title":"Your first Bridge​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#your-first-bridge","content":"Bridges are extremely simple; they're just RemoteEvents, but BridgeNet2-ified! The API is, as said in previous sections, extremely simple and similar to RemoteEvents. The first difference between RemoteEvents and bridges is that bridges are created from strings, and RemoteEvents are instances. You can use the ReferenceBridge function under BridgeNet2 to create a bridge like so: local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;)  info The variable name and the bridge's name don't need to match (as shown later), but it is a recommended practice when using BridgeNet2. It's very important to note that the strings must be the exact same on both the client and the server. But don't worry; BridgeNet2 will warn and tell you something's wrong if it can't find a bridge on the client! "},{"title":"But wait, what about client vs. server?​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#but-wait-what-about-client-vs-server","content":"BridgeNet2's surface level API is almost the exact same, regardless of server and client! ReferenceBridge is used the exact same way on the server and the client. This is because there's no real reason to make them different, apart from typechecking. If you are interested in more &quot;correct&quot; typechecking/autocomplete, you can use the ServerBridge and ClientBridge functions like so: -- On the client.. local myFirstBridgeClientVersion = BridgeNet2.ClientBridge(&quot;myFirstBridge&quot;) -- On the server.. local myFirstBridgeServerVersion = BridgeNet2.ServerBridge(&quot;myFirstBridge&quot;)  caution ClientBridge yields, and so does using ReferenceBridge on the client! You can set a timeout using the second optional timeout parameter. "},{"title":"Firing a bridge​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#firing-a-bridge","content":"The biggest API changes are in the Fire method. You can only pass a single argument in, but this argument can be anything. A table, a string, a boolean, nothing, whatever you want (this will become important later)! One very important differentation from the client's Fire function is that the server's version of the Fire method's first parameter is for the player(s)! local Players = game:GetService(&quot;Players&quot;) local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;) -- On the server.. local you = Players.theReader myFirstBridge:Fire(you, &quot;Hello!&quot;)  "},{"title":"Firing to every single player​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#firing-to-every-single-player","content":"BridgeNet2 has built-in support for firing to multiple players, but there isn't a FireAllClients method! Instead, we have the AllPlayers function. This returns a &quot;symbol&quot; that says &quot;fire this stuff to every single player&quot;. It's used in the same parameter as a singular player, like so: local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;) myFirstBridge:Fire(BridgeNet2.AllPlayers(), &quot;Hello everyone!&quot;)  "},{"title":"Firing to an array of players​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#firing-to-an-array-of-players","content":"Alongside the AllPlayers function there is also the Players function. This function lets you easily fire data to a specific set of players like so: local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;) myFirstBridge:Fire(BridgeNet2.Players({ Players.SpecialPlayerA, Players.SpecialPlayerB }), &quot;Hello special players! Only you get to see this.&quot;)  "},{"title":"Firing to every player except certain players​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#firing-to-every-player-except-certain-players","content":"This function is the inverted version of the Players function. You can fire to everyone except certain players- this is useful for things like client-sided prediction. It can be used just like the Players function: local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;) myFirstBridge:Fire(BridgeNet2.PlayersExcept({ Players.BadPlayerA }), &quot;Everyone except BadPlayerA gets this!&quot;)  "},{"title":"Firing from the client​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#firing-from-the-client","content":"Firing from the client is the exact same as firing on the server, except without the targetPlayer parameter: local firstClientBridge = BridgeNet2.ClientBridge(&quot;myFirstBridge&quot;) firstClientBridge:Fire(&quot;Hey, server!&quot;)  "},{"title":"Connecting to a bridge​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#connecting-to-a-bridge","content":"Connecting to a bridge and connecting to a RemoteEvent are very similar; one's just way shorter! It's basically the exact same: local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;) -- On the client.. myFirstBridge:Connect(function(message) print(message) -- prints &quot;Hello everyone!&quot; end) -- On the server.. myFirstBridge:Connect(function(player, message) print(`{player.Name} said {message}`) -- prints &quot;Client said Hey, server!&quot; end)  "},{"title":"What if I wanted to send multiple things?​","type":1,"pageTitle":"Getting started with BridgeNet2","url":"/BridgeNet2/docs/Tutorials/Getting Started#what-if-i-wanted-to-send-multiple-things","content":"Since BridgeNet2 only allows you to send a singualr argument through Fire, you can just pass a table! -- On the server.. local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;) myFirstBridge:Fire(BridgeNet2.AllPlayers(), { &quot;This is a fully intact array!&quot;, &quot;Tables can store any data you need.&quot;, &quot;You don't need multiple arguments if you can use tables.&quot; })  -- On the client.. local myFirstBridge = BridgeNet2.ReferenceBridge(&quot;myFirstBridge&quot;) myFirstBridge:Connect(function(array) print(array) -- Prints the array we sent from the server end)  "}]