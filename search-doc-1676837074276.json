[{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"With Wally​","type":1,"pageTitle":"Installation","url":"docs/Installation#with-wally","content":"Install WallyPut BridgeNet in the wally.toml file under [dependencies] wally.toml [dependencies] BridgeNet2 = ffrostflame/bridgenet2@0.1.0  Run wally install "},{"title":"Without Wally​","type":1,"pageTitle":"Installation","url":"docs/Installation#without-wally","content":""},{"title":"Option 1: Syncing with .rbxm:​","type":1,"pageTitle":"Installation","url":"docs/Installation#option-1-syncing-with-rbxm","content":"Get the .rbxm file from the latest release.Sync manually or drop into studio manually "},{"title":"Option 2: copying source folder:​","type":1,"pageTitle":"Installation","url":"docs/Installation#option-2-copying-source-folder","content":"Copy the src folder of the repositoryDrop into your projectRename the folder to BridgeNet2 "},{"title":"Identifiers","type":0,"sectionRef":"#","url":"docs/Identifiers","content":"Identifiers The identifier system in BridgeNet2 uses shortened strings to represent constant, static strings and save on bandwidth. The library provides functions to easily create and read identifiers in your code, improving the efficiency of your game by reducing the amount of data transmitted over the network. Using identifiers BridgeNet2 provides functionality to create identifiers without interference in your code. ReferenceIdentifier, FromCompressed and FromIdentifier are utility functions to create and read identifiers.","keywords":""},{"title":"Technical Details","type":0,"sectionRef":"#","url":"docs/Technical Details","content":"","keywords":""},{"title":"It's worth noting that Reference functions (ReferenceBridge and ReferenceIdentifier) have very different behavior depending on if the caller is the client or the server. For example: ReferenceIdentifier can yield on the client, but will never yield on the server.​","type":1,"pageTitle":"Technical Details","url":"docs/Technical Details#its-worth-noting-that-reference-functions-referencebridge-and-referenceidentifier-have-very-different-behavior-depending-on-if-the-caller-is-the-client-or-the-server-for-example-referenceidentifier-can-yield-on-the-client-but-will-never-yield-on-the-server","content":"There are two processes in BridgeNet2: ServerProcess and ClientProcess. The ServerProcess handles communication from the server to the client using the format { [identifierName] = { {uniqueMessage}, {otherUniqueMessage} } }. It is more efficient to use the same bridge for multiple messages, but identifiers can be used to bypass this limitation. The ClientProcess handles communication from the client to the server using the format { [even] = &quot;identifier&quot;, [odd] = {uniqueMessage} }. Identifiers in BridgeNet are generated by the server and use a combination of attributes and string packing to create unique numbers. On the client, identifiers can be accessed using .FromIdentifier(), but it is safer to use .ReferenceIdentifier() as it yields until the identifier is loaded. The server keeps track of the number of identifiers in use and uses this to generate a new identifier when needed. You can find a lot of general knowledge on how Roblox does networking here "},{"title":"Features","type":0,"sectionRef":"#","url":"docs/Features","content":"","keywords":""},{"title":"BridgeNet2 offers a variety of features to improve performance, security, abstraction, and the API of your roblox game.​","type":1,"pageTitle":"Features","url":"docs/Features#bridgenet2-offers-a-variety-of-features-to-improve-performance-security-abstraction-and-the-api-of-your-roblox-game","content":""},{"title":"Performance:​","type":1,"pageTitle":"Features","url":"docs/Features#performance","content":" Significantly faster than the default systems in Roblox. Reduces the overhead of remote calls: client to server takes 5 bytes, server to client takes 2 bytes. Uses an identifier system to reduce bandwidth usage for static strings, which take 3 or 4 bytes regardless of size. Includes utilities for optimization such as FromHex, ToHex, and DictionaryToTable. Reuses threads on connections for increased efficiency. "},{"title":"Security:​","type":1,"pageTitle":"Features","url":"docs/Features#security","content":" Customizable rate limiting for all bridges to prevent remote spamming. Provides middleware for easy typechecking and security implementation. Internally secure to protect against exploitation. "},{"title":"Abstraction:​","type":1,"pageTitle":"Features","url":"docs/Features#abstraction","content":" Queues up remote calls to a player until they are loaded, eliminating the need to worry about the invocation queue. Abstracts instances, eliminating the need to use RemoteEvents. Abstracts away optimization tasks, allowing for easy conversion between dictionaries and arrays. Removes the need to consider client/server boundaries when defining remotes using ReferenceBridge and CreateTree. "},{"title":"API:​","type":1,"pageTitle":"Features","url":"docs/Features#api","content":" Fully typed in strict Luau. Highly performant. Easy to learn and use. Replaces tuples with a more user-friendly system for strict typing. Designed to be extendable, allowing for the implementation of custom systems and whitelists. Includes a testing mode that activates a mock mode that never yields when BridgeNet.Testing(boolean) is called. "},{"title":"BridgeNet2","type":0,"sectionRef":"#","url":"docs/intro","content":"BridgeNet2 BridgeNet2 is an advanced networking library for Roblox that offers a range of features for optimizing, securing, and debugging network communication. Key benefits of using BridgeNet2 include its speed and how it's faster than built-in Roblox networking functions and uses less bandwidth; A load of utility features such as middleware, rate limiting, hexadecimal functions, and optimization functions; and its strict typing, which allows for type checking of both incoming and outgoing data. BridgeNet2 also includes security features such as the ability to control network security and the contents of messages, and it can disrupt the output of RemoteSpy logs, making it harder for exploiters to read them. Why should you use BridgeNet2? Performance: faster than roblox, less bandwidth used than Roblox.Utility features: Middleware, rate limiting, hexadecimal functions, optimization functions, and more.Fully strictly typed: this lets you typecheck what you're sending in, and typecheck what you're sending out.Botches RemoteSpy logs: Since BridgeNet2 sends a special format, it botches RemoteSpy logs and makes the output less readable for exploiters.Security: BridgeNet2 lets you have control over network security, and what the contents of your messages are.Debugging: Tons of useful features for debugging your netcode.Natively written for Luau: There's no leftover features, or half-baked features meant for typescript.No other networking library offers all of these things. Why should you use BridgeNet2 over BridgeNet? BridgeNet2 is far more advanced and resourceful than BridgeNet and other competing libraries. BridgeNet2 is more efficient, with a smaller size in the 200-remotes-a-frame stress test and faster API call times. This makes the library 75% better than Roblox in terms of performance. BridgeNet2's API is enhanced, with better naming, functionality, typings, and runtime typechecking. BridgeNet2 is strictly typed in Luau and includes better utility functions such as ToReadableHex, NumberToBestForm, and more. BridgeNet2 is simpler and easier to maintain, while still offering improved security features like rate-limiting, better runtime typechecking, and better format checking.","keywords":""}]